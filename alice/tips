reverse a list: [::-1]
symetric positions in a list: i and ~i
create a dummy node to track the head of a linked list: head0 = ListNode(0) \ head0.next = head
transform a character to number: ord(char) - ord('a'), a-z -> 0-25
break point: import pdb; pdb.set_trace()
when b = Object(), a = b, a and b point to the same thing, to make a a copy of b, from copy import deepcopy, a = deepcopy(b)
copy a list: new_list = mylist[:]
cur.next, cur, pre = pre, cur.next, cur  # standard reversing

a = [[True]] + [[False]] * len('sdfdgf')
a
a[2][0] = True
a

zfill(length): pad 0 to left

'{:04b}'.format(7)

transpose: t_matrix = zip(*matrix)

753


3轮 给一个数组,找到一个x使得所有小于x的数就等于本身 大于它的数等于x,所有数字相加最接近一个target
比如 [1 3 5 7 9] target=24, answer is8. 因为当x=8,数组里面只有9>8,所以1+3+5+7+8=24最接近target

生长学习法：1.线性结构，2.树形结构，3.图形结构，4.高级算法

DP(终局思想)

union find
binary indexed tree
pre/in/post order
data structure